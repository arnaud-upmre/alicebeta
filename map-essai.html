<!doctype html>
<html lang="fr">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Map Essai - Fonds de carte</title>
    <link href="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.css" rel="stylesheet" />
    <style>
      :root {
        --panel-bg: rgba(255, 255, 255, 0.96);
        --panel-border: rgba(15, 23, 42, 0.12);
        --text: #0f172a;
        --muted: #64748b;
        --accent: #2563eb;
      }

      html,
      body {
        margin: 0;
        width: 100%;
        height: 100%;
        font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
        color: var(--text);
      }

      #map {
        width: 100%;
        height: 100%;
      }

      .panel {
        position: absolute;
        top: 12px;
        left: 12px;
        z-index: 10;
        width: min(360px, calc(100vw - 24px));
        max-height: calc(100vh - 24px);
        overflow: auto;
        background: var(--panel-bg);
        border: 1px solid var(--panel-border);
        border-radius: 12px;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.18);
        padding: 12px 14px;
      }

      .panel h1 {
        margin: 0 0 6px;
        font-size: 16px;
      }

      .panel p {
        margin: 0 0 10px;
        font-size: 13px;
        color: var(--muted);
      }

      .choice {
        display: flex;
        align-items: center;
        gap: 8px;
        padding: 6px 0;
        font-size: 14px;
      }

      .active {
        margin-top: 10px;
        font-size: 13px;
      }

      .active b {
        color: var(--accent);
      }
    </style>
  </head>
  <body>
    <div id="map"></div>

    <aside class="panel">
      <h1>Map essai</h1>
      <p>Comparatif direct entre tes 2 choix vectoriels et leurs equivalents PNG.</p>
      <form id="styles-form">
        <label class="choice">
          <input type="radio" name="style" value="positronBalanced" checked />
          <span>CARTO Positron (vectoriel) - Equilibre</span>
        </label>
        <label class="choice">
          <input type="radio" name="style" value="positronBalancedLabels" />
          <span>CARTO Positron (vectoriel) - Equilibre + labels villes</span>
        </label>
        <label class="choice">
          <input type="radio" name="style" value="positronPng" />
          <span>CARTO Positron (PNG raster)</span>
        </label>
        <label class="choice">
          <input type="radio" name="style" value="voyagerBalanced" />
          <span>CARTO Voyager (vectoriel) - Equilibre</span>
        </label>
        <label class="choice">
          <input type="radio" name="style" value="voyagerBalancedLabels" />
          <span>CARTO Voyager (vectoriel) - Equilibre + labels villes</span>
        </label>
        <label class="choice">
          <input type="radio" name="style" value="voyagerPng" />
          <span>CARTO Voyager (PNG raster)</span>
        </label>
      </form>
      <div class="active">Fond actif: <b id="active-style">CARTO Positron (vectoriel) - Equilibre</b></div>
    </aside>

    <script src="https://unpkg.com/maplibre-gl@5.1.0/dist/maplibre-gl.js"></script>
    <script>
      const centreInitial = [2.9, 50.55];
      const zoomInitial = 8.1;

      const URL_STYLE_POSITRON = "https://basemaps.cartocdn.com/gl/positron-gl-style/style.json";
      const URL_STYLE_VOYAGER = "https://basemaps.cartocdn.com/gl/voyager-gl-style/style.json";

      const styleCache = new Map();

      function styleRaster(id, tiles, attribution, maxzoom = 20) {
        return {
          version: 8,
          sources: {
            [id]: {
              type: "raster",
              tiles,
              tileSize: 256,
              maxzoom,
              attribution
            }
          },
          layers: [
            {
              id,
              type: "raster",
              source: id
            }
          ]
        };
      }

      function cloneDeep(value) {
        return JSON.parse(JSON.stringify(value));
      }

      async function chargerStyleJson(url) {
        if (styleCache.has(url)) {
          return cloneDeep(styleCache.get(url));
        }
        const reponse = await fetch(url, { cache: "default" });
        if (!reponse.ok) {
          throw new Error("Impossible de charger le style: " + url);
        }
        const json = await reponse.json();
        styleCache.set(url, json);
        return cloneDeep(json);
      }

      function contientMot(texte, mots) {
        const normalise = String(texte || "").toLowerCase();
        return mots.some((mot) => normalise.includes(mot));
      }

      function classifierLayer(layer) {
        const id = String(layer?.id || "").toLowerCase();
        const sourceLayer = String(layer?.["source-layer"] || "").toLowerCase();
        const concat = id + " " + sourceLayer;

        const estLabel = layer?.type === "symbol";
        const estRoute = contientMot(concat, [
          "road",
          "roads",
          "street",
          "highway",
          "transportation",
          "transport",
          "path",
          "track",
          "motorway",
          "trunk",
          "primary",
          "secondary",
          "tertiary",
          "residential",
          "service"
        ]);
        const estRouteMineure = contientMot(concat, [
          "minor",
          "residential",
          "service",
          "tertiary",
          "living",
          "pedestrian",
          "footway",
          "path",
          "track",
          "unclassified"
        ]);
        const estLabelRoute = estLabel && contientMot(concat, ["road", "street", "highway", "transport"]);
        const estPoi = contientMot(concat, ["poi", "amenity", "landmark", "shop", "tourism", "leisure", "icon"]);
        const estLabelLocal = estLabel && contientMot(concat, ["neighbour", "neighborhood", "suburb", "quarter", "hamlet", "village"]);
        const estLabelMajeur = estLabel && contientMot(concat, ["country", "state", "region", "city", "town", "place"]);

        return {
          estLabel,
          estRoute,
          estRouteMineure,
          estLabelRoute,
          estPoi,
          estLabelLocal,
          estLabelMajeur
        };
      }

      function masquerLayer(layer) {
        if (!layer.layout) {
          layer.layout = {};
        }
        layer.layout.visibility = "none";
      }

      function pousserMinZoom(layer, minZoom) {
        if (!Number.isFinite(minZoom)) {
          return;
        }
        const courant = Number.isFinite(layer.minzoom) ? layer.minzoom : 0;
        layer.minzoom = Math.max(courant, minZoom);
      }

      function appliquerPresetAllegement(styleJson, preset) {
        const style = cloneDeep(styleJson);
        style.layers = (style.layers || []).map((layer) => {
          const sortie = { ...layer };
          const c = classifierLayer(sortie);

          if (preset === "balanced") {
            if (c.estPoi || c.estLabelLocal) {
              masquerLayer(sortie);
              return sortie;
            }
            if (c.estRouteMineure) {
              pousserMinZoom(sortie, 11);
            }
            if (c.estLabelRoute) {
              pousserMinZoom(sortie, 12);
            }
            return sortie;
          }

          if (preset === "balancedLabels") {
            if (c.estPoi) {
              masquerLayer(sortie);
              return sortie;
            }
            if (c.estRouteMineure) {
              pousserMinZoom(sortie, 11);
            }
            if (c.estLabelRoute) {
              pousserMinZoom(sortie, 12);
            }
            // Garde plus de labels de localites, mais a zoom plus eleve
            // pour ne pas surcharger la carte.
            if (c.estLabelLocal) {
              pousserMinZoom(sortie, 10.5);
            }
            return sortie;
          }

          if (preset === "roadsFocus") {
            if (c.estPoi || c.estLabelLocal) {
              masquerLayer(sortie);
              return sortie;
            }
            if (c.estRouteMineure) {
              masquerLayer(sortie);
              return sortie;
            }
            if (c.estLabelRoute) {
              pousserMinZoom(sortie, 13);
              return sortie;
            }
            if (c.estLabel && !c.estLabelMajeur) {
              pousserMinZoom(sortie, 11);
            }
            return sortie;
          }

          if (preset === "minimal") {
            if (c.estPoi || c.estLabelLocal || c.estLabelRoute || c.estRouteMineure) {
              masquerLayer(sortie);
              return sortie;
            }
            if (c.estRoute) {
              pousserMinZoom(sortie, 10);
              return sortie;
            }
            if (c.estLabel && !c.estLabelMajeur) {
              pousserMinZoom(sortie, 12);
            }
            return sortie;
          }

          return sortie;
        });
        return style;
      }

      function creerVarianteVectorielle(label, baseUrl, preset) {
        return {
          label,
          async getStyle() {
            const base = await chargerStyleJson(baseUrl);
            return appliquerPresetAllegement(base, preset);
          }
        };
      }

      const styles = {
        positronBalanced: creerVarianteVectorielle("CARTO Positron (vectoriel) - Equilibre", URL_STYLE_POSITRON, "balanced"),
        positronBalancedLabels: creerVarianteVectorielle(
          "CARTO Positron (vectoriel) - Equilibre + labels villes",
          URL_STYLE_POSITRON,
          "balancedLabels"
        ),
        positronPng: {
          label: "CARTO Positron (PNG raster)",
          style: styleRaster(
            "positronRaster",
            [
              "https://a.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
              "https://b.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
              "https://c.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png",
              "https://d.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png"
            ],
            "© OpenStreetMap contributors, © CARTO"
          )
        },
        voyagerBalanced: creerVarianteVectorielle("CARTO Voyager (vectoriel) - Equilibre", URL_STYLE_VOYAGER, "balanced"),
        voyagerBalancedLabels: creerVarianteVectorielle(
          "CARTO Voyager (vectoriel) - Equilibre + labels villes",
          URL_STYLE_VOYAGER,
          "balancedLabels"
        ),
        voyagerPng: {
          label: "CARTO Voyager (PNG raster)",
          style: styleRaster(
            "voyagerRaster",
            [
              "https://a.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png",
              "https://b.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png",
              "https://c.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png",
              "https://d.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}.png"
            ],
            "© OpenStreetMap contributors, © CARTO"
          )
        }
      };

      const activeStyleLabel = document.getElementById("active-style");
      const stylesForm = document.getElementById("styles-form");

      const map = new maplibregl.Map({
        container: "map",
        style: URL_STYLE_POSITRON,
        center: centreInitial,
        zoom: zoomInitial,
        attributionControl: false
      });

      map.addControl(new maplibregl.NavigationControl({ showCompass: false }), "top-right");
      map.addControl(new maplibregl.ScaleControl({ maxWidth: 120, unit: "metric" }), "bottom-left");
      map.addControl(new maplibregl.AttributionControl({ compact: true }), "bottom-right");

      async function appliquerStyle(cleStyle) {
        const entree = styles[cleStyle];
        if (!entree) {
          return;
        }
        activeStyleLabel.textContent = entree.label + " (chargement...)";
        const centre = map.getCenter();
        const zoom = map.getZoom();
        const bearing = map.getBearing();
        const pitch = map.getPitch();

        let styleFinal = entree.style;
        if (typeof entree.getStyle === "function") {
          try {
            styleFinal = await entree.getStyle();
          } catch (erreur) {
            console.error("Impossible de preparer la variante de style", erreur);
            activeStyleLabel.textContent = entree.label + " (erreur de chargement)";
            return;
          }
        }

        map.setStyle(styleFinal);
        map.once("style.load", () => {
          map.jumpTo({
            center: centre,
            zoom,
            bearing,
            pitch
          });
        });

        activeStyleLabel.textContent = entree.label;
      }

      stylesForm.addEventListener("change", (event) => {
        const valeur = event.target && event.target.value;
        if (!valeur) {
          return;
        }
        appliquerStyle(valeur);
      });

      map.once("load", () => {
        appliquerStyle("positronBalanced");
      });
    </script>
  </body>
</html>
